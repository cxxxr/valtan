#+valtan
(in-package :common-lisp)
#-valtan
(in-package :valtan-core)

(declaim (ftype function atom))

(defun %db-length (list)
  (do ((l list (cdr l))
       (count 0 (+ count 1)))
      ((atom l) count)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *db-bindings*)
  (defvar *tmp-db-vars*)
  (defun parse-db-lambda-list (lambda-list arg)
    (macrolet ((%push (x cl:list)
                 `(setq ,cl:list (cl:cons ,x ,cl:list)))
               (%pop (cl:list)
                 `(cl:prog1 (cl:car ,cl:list) (setq ,cl:list (cl:cdr ,cl:list))))
               (%incf (var &optional (n 1))
                 `(setq ,var (cl:+ ,var ,n))))
      (flet ((db-gensym (&optional arg)
               (cl:car
                (%push
                 (if arg
                     (cl:gensym arg)
                     (cl:gensym))
                 *tmp-db-vars*)))
             (make-keyword (x)
               (cl:intern (cl:string x) :keyword))
             (invalid-lambda-list ()
               (cl:error "Invalid lambda list: ~S" lambda-list)))
        (let ((path arg)
              (cl:min 0)
              (cl:max 0)
              (state nil)
              (optionalp nil)
              (restp nil)
              (keyp nil)
              (keys nil)
              (allow-other-keys-p nil)
              (check-arg-placeholder)
              (check-key-placeholder))
          (%push (setq check-arg-placeholder (cl:list (db-gensym) nil)) *db-bindings*)
          (cl:when (eq 'cl:&whole (cl:first lambda-list))
            (%pop lambda-list)
            (cl:unless lambda-list (invalid-lambda-list))
            (%push (cl:list (%pop lambda-list) arg) *db-bindings*))
          (cl:do ((ll lambda-list (cl:rest ll)))
                 ((cl:atom ll) (cl:when ll (setq restp t) (%push (cl:list ll path) *db-bindings*)))
            (let ((x (cl:first ll)))
              (cl:cond
               ((eq state :aux)
                (cl:cond ((symbolp x) (%push (cl:list x nil) *db-bindings*))
                         ((cl:consp x)
                          (cl:case (cl:length x)
                            ((1 2) (%push (cl:list (cl:first x) (cl:second x)) *db-bindings*))
                            (cl:otherwise (invalid-lambda-list))))
                         (t (invalid-lambda-list))))
               ((eq x 'cl:&aux) (setq state :aux))
               ((eq x 'cl:&allow-other-keys) (cl:unless (eq state :key) (invalid-lambda-list))
                (setq allow-other-keys-p t))
               ((eq x 'cl:&key) (cl:when keyp (invalid-lambda-list))
                (%push (setq check-key-placeholder (cl:list (db-gensym) path)) *db-bindings*)
                (setq state :key) (setq keyp t))
               ((eq state :key) (%incf cl:max 2)
                (cl:cond
                 ((symbolp x)
                  (let ((key (make-keyword x)))
                    (%push key keys)
                    (%push (cl:list x `(cl:getf ,path ,key)) *db-bindings*)))
                 ((cl:consp x)
                  (let ((len (cl:length x)))
                    (cl:cond
                     ((cl:<= 1 len 3)
                      (let ((key (make-keyword (cl:first x))))
                        (%push key keys)
                        (let ((supplied-value (db-gensym)) (default ''#:default))
                          (%push (cl:list supplied-value `(cl:getf ,path ,key ,default))
                           *db-bindings*)
                          (cl:when (cl:= len 3)
                            (%push (cl:list (cl:third x) `(eq ,supplied-value ,default))
                             *db-bindings*))
                          (%push
                           (cl:list (cl:first x)
                                    `(if (eq ,supplied-value ,default)
                                         ,(cl:second x)
                                         ,supplied-value))
                           *db-bindings*))))
                     (t (invalid-lambda-list)))))
                 (t (invalid-lambda-list))))
               ((cl:member x '(&rest &body)) (setq restp t)
                (cl:cond
                 ((cl:and (cl:rest ll) (symbolp (cl:second ll)))
                  (%push (cl:list (cl:second ll) path) *db-bindings*) (%pop ll))
                 ((cl:and (cl:rest ll) (cl:consp (cl:second ll)))
                  (let ((tmp (db-gensym "TMP")))
                    (%push (cl:list tmp path) *db-bindings*)
                    (parse-db-lambda-list (cl:second ll) tmp)))
                 (t (invalid-lambda-list))))
               ((eq x '&optional) (cl:when optionalp (invalid-lambda-list)) (setq state :optional)
                (setq optionalp t))
               ((eq state :optional) (%incf cl:max)
                (cl:cond
                 ((symbolp x) (%push (cl:list x `(cl:first ,path)) *db-bindings*)
                  (let ((cdr-var (db-gensym "TMP")))
                    (%push (cl:list cdr-var `(cl:rest ,path)) *db-bindings*)
                    (setq path cdr-var)))
                 ((cl:consp x)
                  (let ((len (cl:length x)))
                    (cl:cond
                     ((cl:<= 1 len 3)
                      (cl:when (cl:= len 3)
                        (%push
                         (cl:list (cl:third x)
                                  `(if ,path
                                       t
                                       nil))
                         *db-bindings*))
                      (%push
                       (cl:list (cl:first x)
                                `(if ,path
                                     (cl:first ,path)
                                     ,(cl:second x)))
                       *db-bindings*)
                      (let ((cdr-var (db-gensym "TMP")))
                        (%push (cl:list cdr-var `(cl:rest ,path)) *db-bindings*)
                        (setq path cdr-var)))
                     (t (invalid-lambda-list)))))
                 (t (invalid-lambda-list))))
               ((cl:listp x) (%incf cl:min) (%incf cl:max)
                (let ((car-var (db-gensym "TMP")))
                  (%push (cl:list car-var `(cl:first ,path)) *db-bindings*)
                  (parse-db-lambda-list x car-var))
                (let ((cdr-var (db-gensym "TMP")))
                  (%push (cl:list cdr-var `(cl:rest ,path)) *db-bindings*)
                  (setq path cdr-var)))
               (t (cl:unless (symbolp x) (invalid-lambda-list)) (%incf cl:min) (%incf cl:max)
                (%push (cl:list x `(cl:first ,path)) *db-bindings*)
                (let ((cdr-var (db-gensym "TMP")))
                  (%push (cl:list cdr-var `(cl:rest ,path)) *db-bindings*)
                  (setq path cdr-var))))))
          (cl:rplaca (cl:cdr check-arg-placeholder)
                     `(cl:unless
                          ,(if (cl:or restp keyp)
                               `(cl:<= ,cl:min (%db-length ,arg))
                               `(cl:<= ,cl:min (%db-length ,arg) ,cl:max))
                        (cl:error "Invalid number of arguments for destructuring-bind: ~S ~S"
                                  ',lambda-list ,arg)))
          (cl:when (cl:and check-key-placeholder (cl:not allow-other-keys-p))
            (cl:rplaca (cl:cdr check-key-placeholder)
                       (let ((plist (cl:gensym)))
                         `(cl:do ((,plist ,(cl:second check-key-placeholder) (cl:cddr ,plist)))
                                 ((cl:null ,plist))
                            (cl:unless
                                (cl:or
                                 ,@(cl:mapcar (lambda (key) `(eq ,key (cl:first ,plist))) keys))
                              (cl:error "Unknown &key argument: ~S" (cl:first ,plist)))))))))))
  (defun expand-destructuring-bind (lambda-list expression body)
    (let ((*db-bindings* 'nil) (*tmp-db-vars* 'nil) (g-expression (cl:gensym)))
      (parse-db-lambda-list lambda-list g-expression)
      `(let ((,g-expression ,expression))
         (let* ,(cl:nreverse *db-bindings*)
           (declare (cl:ignorable . ,*tmp-db-vars*))
           ,@body)))))

(*:defmacro* destructuring-bind (lambda-list expression &rest body)
  (expand-destructuring-bind lambda-list expression body))
